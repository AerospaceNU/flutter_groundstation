import 'package:auto_size_text/auto_size_text.dart';
import 'package:flutter/material.dart';
import 'package:flutter_groundstation/constants.dart';
import 'package:flutter_groundstation/widgets/base_widget.dart';
import 'package:flutter_groundstation/widgets/text_data.dart';
import '../database.dart';

/// Flutter widget which displays how 'full' something is in the form
/// of a [BatteryIndicator].
///
/// The 'fullness' of the indicator is determined on construction by
/// the [max] and [min] parameters, and the current value of the data,
/// [_batteryLevel], which corresponds to [dataKey] in the [Database].
///
/// - If [_batteryLevel] is above [high], the battery level is colored
/// [Colors.green].
/// - If [_batteryLevel] is below [high] but still above [low], the
/// battery level is colored [Colors.orange].
///  - If [_batteryLevel] is below [low], the battery level is colored
/// [Colors.red]
class BatteryIndicator extends StatefulWidget {
  /// [AutoSizeTextBuilder] that is used to build the autogenerated
  /// textual widgets.
  final AutoSizeTextBuilder? textBuilder;
  /// Autogenerated textual widget placed above the [BatteryIndicator]
  /// that describes what the [BatteryIndicator] indicates.
  late final Widget? title;
  /// Autogenerated textual widget placed under the [BatteryIndicator]
  /// which displays the raw data the [BatteryIndicator] indicates.
  late final Widget? data;
  /// Size of the [BatteryIndicator] widget. Only counts for the
  /// [CustomPainter], not the textual displays attached to this
  /// widget.
  late final Size size;
  /// [dataKey] to the data to display in the [Database].
  final String dataKey;
  /// Label to put above the [batteryIndicator].
  final String? label;
  /// Maximum value the read data can reach. Used to determine how
  /// the [BatteryIndicator] is drawn.
  final double max;
  /// Minimum value the read data can reach. Used to determine how
  /// the [BatteryIndicator] is drawn.
  final double min;
  /// Threshold value for which to consider the data to be good
  /// (whatever is above is [Color.green]).
  /// Used to determine how the [BatteryIndicator] is drawn.
  final double high;
  /// Threshold value for which to consider the data to be good
  /// (whatever is below is [Color.red]).
  /// Used to determine how the [BatteryIndicator] is drawn.
  final double low;
  /// Whether or not to display raw data under the [BatteryIndicator].
  final bool displayData;

  BatteryIndicator({super.key,
    required this.dataKey,
    this.label,
    this.max = 100,
    this.min = 0,
    this.high = 0.5,
    this.low = 0.3,
    double width = double.infinity,
    double height = double.infinity,
    this.displayData = false,
    this.textBuilder,
  }) {
    assert(max > min);
    title = (label != null) ? (textBuilder != null ? textBuilder?.build(label!)
        : AutoSizeText(label!, presetFontSizes: Constants.stdFontSizes,)) : null;
    data = displayData
        ? TextData(dataKey: dataKey, decimals: 6, textBuilder: textBuilder)
        : null;
    size = Size(width, height);
  }

  @override
  State<StatefulWidget> createState() => _BatteryState();
}

/// State of [BatteryIndicator] that draws an indicator of how 'full'
/// something is based on data that corresponds to [widget.dataKey] in
/// the [Database] and the [widget.max], [widget.min], [widget.high],
/// and [widget.low] parameters.
class _BatteryState extends BaseWidgetState<BatteryIndicator> {
  @override
  void initState() {
    super.subscribeToDatabaseKey(widget.dataKey);
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return Column(children: [
      Expanded(
        child: widget.title != null ? widget.title! : const Padding(padding: EdgeInsets.all(1)),
      ),
      Expanded(
          flex: 4,
          child: CustomPaint(
            painter: _BatteryLevelPainter(
                getDatabaseValue(widget.dataKey, widget.min),
                this, widget.min, widget.max, widget.high, widget.low),
            size: widget.size,
            willChange: true,
          )
      ),
      Flexible(
          child : widget.data != null ? widget.data! : const Padding(padding: EdgeInsets.all(1))
      ),
    ]
    );
  }
}

// https://stackoverflow.com/questions/71584932/battery-level-indicator-drawing-upside-down-in-flutter-custompainter-class
// 100% not taken from stackoverflow.
/// [CustomPainter] that paints the battery icon and fills it in.
/// - If [_batteryLevel] is above [high], the battery level is colored
/// [Colors.green].
/// - If [_batteryLevel] is below [high] but still above [low], the
/// battery level is colored [Colors.orange].
///  - If [_batteryLevel] is below [low], the battery level is colored
/// [Colors.red]
class _BatteryLevelPainter extends CustomPainter {
  /// Current data read from the [Database].
  final double _batteryLevel;
  /// Parent state.
  final _BatteryState _batteryState;
  /// Maximum value the read data can reach. Used to determine how
  /// the [BatteryIndicator] is drawn.
  final double max;
  /// Minimum value the read data can reach. Used to determine how
  /// the [BatteryIndicator] is drawn.
  final double min;
  /// Threshold value for which to consider the data to be good
  /// (whatever is above is [Colors.green]).
  /// Used to determine how the [BatteryIndicator] is drawn.
  final double high;
  /// Threshold value for which to consider the data to be good
  /// (whatever is below is [Colors.red]).
  /// Used to determine how the [BatteryIndicator] is drawn.
  final double low;

  _BatteryLevelPainter(this._batteryLevel, this._batteryState, this.min, this.max, this.high, this.low);

  @override
  void paint(Canvas canvas, Size size) {
    Paint getPaint({Color color = Colors.black, PaintingStyle style = PaintingStyle.stroke}) {
      return Paint()
        ..color = color
        ..strokeWidth = 1.0
        ..style = style;
    }
    final RRect batteryOutline = RRect.fromLTRBR(0.0, 0.0, size.width, size.height, const Radius.circular(2.0));

    // Battery body
    canvas.drawRRect(
      batteryOutline,
      getPaint(),
    );

    double range = (max-min).abs();
    double percentFull = ((_batteryLevel - min) / range);

    canvas.translate(0.0, (size.height - size.height * percentFull));
    // Fill rect
    canvas.clipRect(Rect.fromLTWH(0.0, 0.0, size.width, size.height * percentFull));

    Color indicatorColor;

    if (percentFull < low) {
      indicatorColor = Colors.red;
    } else if (percentFull < high) {
      indicatorColor = Colors.orange;
    } else {
      indicatorColor = Colors.green;
    }

    canvas.drawRRect(
      RRect.fromLTRBR(0.5, 0.5, size.width - 0.5, size.height - 0.5, const Radius.circular(2.0)),
      getPaint(style: PaintingStyle.fill, color: indicatorColor),
    );
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) {
    final _BatteryLevelPainter old = oldDelegate as _BatteryLevelPainter;

    return old._batteryLevel != _batteryLevel || old._batteryState != _batteryState;
  }
}