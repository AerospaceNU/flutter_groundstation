import 'package:auto_size_text/auto_size_text.dart';
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:flutter_groundstation/database.dart';

import '../constants.dart';
import 'base_widget.dart';

/// Text widget that displays a mapping of some widget to a [TextData].
class EntryData extends StatelessWidget {
  /// [AutoSizeTextBuilder] that is used to build the autogenerated
  /// textual widgets.
  final AutoSizeTextBuilder builder;

  /// MapEntry pair to display. conventionally [{label : dataKey}].
  ///
  /// If strings are put in, they will be automatically converted to
  /// [AutoSizeText] widgets built using [builder].
  final MapEntry entry;

  /// The amount of padding to put around the text.
  ///
  /// Default value is [EdgeInsets.zero]
  final EdgeInsets padding;

  const EntryData({super.key, required this.entry, this.padding = EdgeInsets.zero, this.builder = const AutoSizeTextBuilder()});

  @override
  Widget build(BuildContext context) {
    return Row(children: [
      Expanded(
          child: Padding(
        padding: padding,
        child: entry.key is Widget ? entry.key as Widget : builder.build(entry.key.toString()),
      )),
      Expanded(
        child: Padding(padding: padding, child: entry.value is Widget ? entry.value as Widget : builder.build(entry.value.toString())),
      ),
    ]);
  }
}

/// Text widget that displays data from the [Database] given a [dataKey].
///
/// Can automatically resize to fit within its bounds.
class TextData extends StatefulWidget {
  final AutoSizeText? text = null;

  /// [AutoSizeTextBuilder] that is used to build the
  /// autogenerated textual widgets.
  final AutoSizeTextBuilder? textBuilder;

  /// The key used to query the [Database] with.
  final String dataKey;

  /// The number of decimal places to round the displayed
  /// data to.
  final int? decimals;

  /// The text style to apply.
  final TextStyle? style;

  /// The minimum text size constraint to be used when auto-sizing text.
  ///
  /// Is being ignored if [presetFontSizes] is set.
  final double minFontSize;

  /// The maximum text size constraint to be used when auto-sizing text.
  ///
  /// Is being ignored if [presetFontSizes] is set.
  final double maxFontSize;

  /// The step size in which the font size is being adapted to constraints.
  ///
  /// The Text scales uniformly in a range between [minFontSize] and
  /// [maxFontSize].
  /// Each increment occurs as per the step size set in stepGranularity.
  ///
  /// Most of the time you don't want a stepGranularity below 1.0.
  ///
  /// Is being ignored if [presetFontSizes] is set.
  final double stepGranularity;

  /// Predefines all the possible font sizes.
  ///
  /// **Important:** PresetFontSizes have to be in descending order.
  final List<double>? presetFontSizes;

  /// Synchronizes the size of multiple [AutoSizeText]s.
  ///
  /// If you want multiple [AutoSizeText]s to have the same text size, give all
  /// of them the same [AutoSizeGroup] instance. All of them will have the
  /// size of the smallest [AutoSizeText]
  final AutoSizeGroup? group;

  /// How the text should be aligned horizontally.
  final TextAlign? textAlign;

  /// The directionality of the text.
  ///
  /// This decides how [textAlign] values like [TextAlign.start] and
  /// [TextAlign.end] are interpreted.
  ///
  /// This is also used to disambiguate how to render bidirectional text. For
  /// example, if the [data] is an English phrase followed by a Hebrew phrase,
  /// in a [TextDirection.ltr] context the English phrase will be on the left
  /// and the Hebrew phrase to its right, while in a [TextDirection.rtl]
  /// context, the English phrase will be on the right and the Hebrew phrase on
  /// its left.
  ///
  /// Defaults to the ambient [Directionality], if any.
  final TextDirection? textDirection;

  /// Used to select a font when the same Unicode character can
  /// be rendered differently, depending on the locale.
  ///
  /// It's rarely necessary to set this property. By default its value
  /// is inherited from the enclosing app with `Localizations.localeOf(context)`.
  ///
  /// See [RenderParagraph.locale] for more information.
  final Locale? locale;

  /// Whether the text should break at soft line breaks.
  ///
  /// If false, the glyphs in the text will be positioned as if there was unlimited horizontal space.
  ///
  /// This also decides the [overflow] property's behavior. If this is true or null,
  /// the glyph causing overflow, and those that follow, will not be rendered.
  final bool? softWrap;

  /// Whether words which don't fit in one line should be wrapped.
  ///
  /// If false, the fontSize is lowered as far as possible until all words fit
  /// into a single line.
  final bool wrapWords;

  /// How visual overflow should be handled.
  ///
  /// If [softWrap] is true or null, the glyph causing overflow, and those that follow,
  /// will not be rendered. Otherwise, it will be shown with the given overflow option.
  final TextOverflow? overflow;

  /// If the text is overflowing and does not fit its bounds, this widget is
  /// displayed instead.
  final Widget? overflowReplacement;

  /// The number of font pixels for each logical pixel.
  ///
  /// For example, if the text scale factor is 1.5, text will be 50% larger than
  /// the specified font size.
  ///
  /// The value given to the constructor as textScaleFactor. If null, will
  /// use the [MediaQueryData.textScaleFactor] obtained from the ambient
  /// [MediaQuery], or 1.0 if there is no [MediaQuery] in scope.
  final double? textScaleFactor;

  /// An optional maximum number of lines for the text to span, wrapping if necessary.
  /// If the text exceeds the given number of lines, it will be truncated according
  /// to [overflow].
  ///
  /// If this is 1, text will not wrap. Otherwise, text will be wrapped at the
  /// edge of the box.
  ///
  /// If this is non-null, it will override even explicit null values of
  /// [Text.maxLines].
  final int? maxLines;

  /// {@template flutter.widgets.Text.semanticsLabel}
  /// An alternative semantics label for this text.
  ///
  /// If present, the semantics of this widget will contain this value instead
  /// of the actual text. This will overwrite any of the semantics labels applied
  /// directly to the [TextSpan]s.
  ///
  /// This is useful for replacing abbreviations or shorthands with the full
  /// text value:
  ///
  /// ```dart
  /// const Text(r'$$', semanticsLabel: 'Double dollars')
  /// ```
  /// {@endtemplate}
  final String? semanticsLabel;

  final String? prefix;
  final String? suffix;

  /// Creates a [TextData] widget.
  ///
  /// If [textBuilder] argument is not null, the will be used to
  /// create the [AutoSizeText] widgets ignoring all other styling
  /// and formatting arguments other than how many [decimals] to
  /// round the data to.
  const TextData({
    super.key,
    required this.dataKey,
    this.decimals,
    this.style,
    this.minFontSize = 12,
    this.maxFontSize = double.infinity,
    this.stepGranularity = 1,
    this.presetFontSizes = Constants.stdFontSizes,
    this.group,
    this.textAlign,
    this.textDirection,
    this.locale,
    this.softWrap,
    this.wrapWords = true,
    this.overflow,
    this.overflowReplacement,
    this.textScaleFactor,
    this.maxLines,
    this.semanticsLabel,
    this.textBuilder,
    this.prefix,
    this.suffix,
  });

  @override
  State<StatefulWidget> createState() => _DataDisplayState();
}

/// State of [TextData] widget that updates the displayed text
/// to whatever the data which corresponds to [widget.dataKey]
/// in the [Database].
class _DataDisplayState extends BaseWidgetState<TextData> {
  @override
  void initState() {
    super.initState();
    super.subscribeToDatabaseKey(widget.dataKey);
  }

  @override
  Widget build(BuildContext context) {
    //I grafted in some hacky code to let you add more text around the value - Nathan
    final data = getData().toString();
    final prefix = widget.prefix;
    final suffix = widget.suffix;

    String textToWrite = "";
    if (prefix != null && prefix.isNotEmpty) {
      textToWrite = prefix;
    }

    textToWrite += data;

    if (suffix != null && suffix.isNotEmpty) {
      textToWrite += suffix;
    }

    return widget.textBuilder != null
        ? widget.textBuilder!.build(data.toString())
        : AutoSizeText(
            textToWrite,
            style: widget.style,
            minFontSize: widget.minFontSize,
            maxFontSize: widget.maxFontSize,
            stepGranularity: widget.stepGranularity,
            presetFontSizes: widget.presetFontSizes,
            group: widget.group,
            textAlign: widget.textAlign,
            textDirection: widget.textDirection,
            locale: widget.locale,
            softWrap: widget.softWrap,
            wrapWords: widget.wrapWords,
            overflow: widget.overflow,
            overflowReplacement: widget.overflowReplacement,
            textScaleFactor: widget.textScaleFactor,
            maxLines: widget.maxLines,
            semanticsLabel: widget.semanticsLabel,
          );
  }

  /// Gets data from the [Database] using [widget.dataKey].
  Object getData() {
    var data = super.getDatabaseValueOrNull(widget.dataKey);
    const defaultVal = "N\\A";
    if (data is num && widget.decimals != null) {
      data = data.toStringAsFixed(widget.decimals!).removeTrailingZero();
    }
    return data ?? defaultVal;
  }
}

extension StringRegEx on String {
  /// Removes trailing zeros off of the string.
  String removeTrailingZero() {
    if (!contains('.')) {
      return this;
    }
    String trimmed = replaceAll(RegExp(r'0*$'), '');
    if (!trimmed.endsWith('.')) {
      return trimmed;
    }
    return trimmed.substring(0, trimmed.length - 1);
  }
}

/// An AutoSizeText widget builder to create [AutoSizeText] with specific
/// parameters.
class AutoSizeTextBuilder {
  /// The text style to apply.
  final TextStyle? style;

  /// The minimum text size constraint to be used when auto-sizing text.
  ///
  /// Is being ignored if [presetFontSizes] is set.
  final double? minFontSize;

  /// The maximum text size constraint to be used when auto-sizing text.
  ///
  /// Is being ignored if [presetFontSizes] is set.
  final double? maxFontSize;

  /// The step size in which the font size is being adapted to constraints.
  ///
  /// The Text scales uniformly in a range between [minFontSize] and
  /// [maxFontSize].
  /// Each increment occurs as per the step size set in stepGranularity.
  ///
  /// Most of the time you don't want a stepGranularity below 1.0.
  ///
  /// Is being ignored if [presetFontSizes] is set.
  final double? stepGranularity;

  /// Predefines all the possible font sizes.
  ///
  /// **Important:** PresetFontSizes have to be in descending order.
  final List<double>? presetFontSizes;

  /// Synchronizes the size of multiple [AutoSizeText]s.
  ///
  /// If you want multiple [AutoSizeText]s to have the same text size, give all
  /// of them the same [AutoSizeGroup] instance. All of them will have the
  /// size of the smallest [AutoSizeText]
  final AutoSizeGroup? group;

  /// How the text should be aligned horizontally.
  final TextAlign? textAlign;

  /// The directionality of the text.
  ///
  /// This decides how [textAlign] values like [TextAlign.start] and
  /// [TextAlign.end] are interpreted.
  ///
  /// This is also used to disambiguate how to render bidirectional text. For
  /// example, if the [data] is an English phrase followed by a Hebrew phrase,
  /// in a [TextDirection.ltr] context the English phrase will be on the left
  /// and the Hebrew phrase to its right, while in a [TextDirection.rtl]
  /// context, the English phrase will be on the right and the Hebrew phrase on
  /// its left.
  ///
  /// Defaults to the ambient [Directionality], if any.
  final TextDirection? textDirection;

  /// Used to select a font when the same Unicode character can
  /// be rendered differently, depending on the locale.
  ///
  /// It's rarely necessary to set this property. By default its value
  /// is inherited from the enclosing app with `Localizations.localeOf(context)`.
  ///
  /// See [RenderParagraph.locale] for more information.
  final Locale? locale;

  /// Whether the text should break at soft line breaks.
  ///
  /// If false, the glyphs in the text will be positioned as if there was unlimited horizontal space.
  ///
  /// This also decides the [overflow] property's behavior. If this is true or null,
  /// the glyph causing overflow, and those that follow, will not be rendered.
  final bool? softWrap;

  /// Whether words which don't fit in one line should be wrapped.
  ///
  /// If false, the fontSize is lowered as far as possible until all words fit
  /// into a single line.
  final bool? wrapWords;

  /// How visual overflow should be handled.
  ///
  /// If [softWrap] is true or null, the glyph causing overflow, and those that follow,
  /// will not be rendered. Otherwise, it will be shown with the given overflow option.
  final TextOverflow? overflow;

  /// If the text is overflowing and does not fit its bounds, this widget is
  /// displayed instead.
  final Widget? overflowReplacement;

  /// The number of font pixels for each logical pixel.
  ///
  /// For example, if the text scale factor is 1.5, text will be 50% larger than
  /// the specified font size.
  ///
  /// The value given to the constructor as textScaleFactor. If null, will
  /// use the [MediaQueryData.textScaleFactor] obtained from the ambient
  /// [MediaQuery], or 1.0 if there is no [MediaQuery] in scope.
  final double? textScaleFactor;

  /// An optional maximum number of lines for the text to span, wrapping if necessary.
  /// If the text exceeds the given number of lines, it will be truncated according
  /// to [overflow].
  ///
  /// If this is 1, text will not wrap. Otherwise, text will be wrapped at the
  /// edge of the box.
  ///
  /// If this is non-null, it will override even explicit null values of
  /// [Text.maxLines].
  final int? maxLines;

  /// {@template flutter.widgets.Text.semanticsLabel}
  /// An alternative semantics label for this text.
  ///
  /// If present, the semantics of this widget will contain this value instead
  /// of the actual text. This will overwrite any of the semantics labels applied
  /// directly to the [TextSpan]s.
  ///
  /// This is useful for replacing abbreviations or shorthands with the full
  /// text value:
  ///
  /// ```dart
  /// const Text(r'$$', semanticsLabel: 'Double dollars')
  /// ```
  /// {@endtemplate}
  final String? semanticsLabel;

  /// Creates a [AutoSizeTextBuilder] that will build [AutoSizeText] widgets
  /// with the specified parameters.
  ///
  /// All default values are set properly except for [presetFontSizes], which
  /// is set to [TwoColumnDisplay.stdFontSizes] for optimization.
  const AutoSizeTextBuilder({
    this.style,
    this.minFontSize = 12,
    this.maxFontSize = double.infinity,
    this.stepGranularity = 1,
    this.presetFontSizes = Constants.stdFontSizes,
    this.group,
    this.textAlign,
    this.textDirection,
    this.locale,
    this.softWrap,
    this.wrapWords = true,
    this.overflow,
    this.overflowReplacement,
    this.textScaleFactor,
    this.maxLines,
    this.semanticsLabel,
  });

  // values that require not null are handled by saying
  //
  // _variable ?? default_value,
  //
  // since the way these builders are constructed force
  // any unspecified parameters to be null, causing some
  // type error. basically bad code.
  /// Creates a [AutoSizeText] widget with the pre-determined parameters.
  AutoSizeText build(String data) {
    return AutoSizeText(
      data,
      style: style,
      minFontSize: minFontSize ?? 12,
      maxFontSize: maxFontSize ?? double.infinity,
      stepGranularity: stepGranularity ?? 1,
      presetFontSizes: presetFontSizes,
      group: group,
      textAlign: textAlign,
      textDirection: textDirection,
      locale: locale,
      softWrap: softWrap,
      wrapWords: wrapWords ?? true,
      overflow: overflow,
      overflowReplacement: overflowReplacement,
      textScaleFactor: textScaleFactor,
      maxLines: maxLines,
      semanticsLabel: semanticsLabel,
    );
  }
}
